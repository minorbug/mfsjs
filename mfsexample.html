<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MFS Library MacPaint Example with Visualization</title>
    <script src="mfs.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { max-width: 900px; width: 100%; }
        button { padding: 10px 15px; font-size: 16px; cursor: pointer; margin-bottom: 20px; }
        #downloadLinkContainer { margin-top: 10px; margin-bottom: 20px; }
        a { color: #007bff; }
        pre { background-color: #f4f4f4; padding: 10px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; max-height: 200px; overflow-y: auto; }
        
        #diskVisualizationContainer {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 2px; /* Small gap between blocks */
            width: 100%; /* Adjust as needed */
            background-color: #e9e9e9;
        }
        .disk-block {
            width: 10px; /* Adjust for desired size */
            height: 10px; /* Adjust for desired size */
            font-size: 6px; /* For block numbers if shown */
            line-height: 10px;
            text-align: center;
            border: 1px solid #fff; /* White border for separation */
            box-sizing: border-box;
            position: relative; /* For tooltips or other overlays */
        }
        .block-boot { background-color: #ff6347; /* Tomato */ }
        .block-mdb { background-color: #ffa500; /* Orange */ }
        .block-dir-reserved { background-color: #ffd700; /* Gold */ }
        .block-file-data { background-color: #90ee90; /* LightGreen */ }
        .block-file-rsrc { background-color: #add8e6; /* LightBlue */ }
        .block-dir-alloc { background-color: #ffebcd; /* BlanchedAlmond - directory using alloc block */ }
        .block-free { background-color: #d3d3d3; /* LightGray */ }
        .block-unknown { background-color: #708090; /* SlateGray */ }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none; /* So it doesn't interfere with mouse events on blocks */
            white-space: pre;
            z-index: 1000;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MFS Library: Create Disk with MacPaint Checkerboard & Visualization</h1>
        <p>This example will use the <code>mfs.js</code> library to:</p>
        <ol>
            <li>Create a new 400KB MFS-formatted disk image in memory.</li>
            <li>Generate data for a 576x720 monochrome MacPaint file with an 8x8 pixel checkerboard pattern.</li>
            <li>Save this MacPaint file (named "Checker.ptng") to the disk image.</li>
            <li>Provide a download link for the generated disk image ("CheckerDisk.dsk").</li>
            <li>Display a graphical visualization of the disk layout.</li>
        </ol>
        <button id="createImageBtn">Create Disk Image & Add Checkerboard</button>
        <div id="downloadLinkContainer"></div>
        <pre id="logOutput"></pre>
        
        <h2>Disk Visualization</h2>
        <div id="diskVisualizationContainer"></div>
        <div id="tooltip"></div>
    </div>

    <script>
        const logOutput = document.getElementById('logOutput');
        const visualizationContainer = document.getElementById('diskVisualizationContainer');
        const tooltip = document.getElementById('tooltip');

        function log(message) {
            console.log(message); // Also log to browser console
            logOutput.textContent += message + '\n';
            logOutput.scrollTop = logOutput.scrollHeight; // Auto-scroll
        }

        function generateCheckerboardMacPaintData() {
            // This function generates data for an 8x8 pixel checkerboard pattern.
            // The debug logs confirm that the byte values produced (e.g., 0xFF for a black 8-pixel segment,
            // 0x00 for a white 8-pixel segment) correctly correspond to an 8x8 checkerboard.
            // If the visual output in a MacPaint viewer shows something different (e.g., 1-pixel stripes),
            // it may indicate an issue with how the viewer interprets this raw bitmap data,
            // or that the image being viewed was not generated by this exact code.
            log("Generating MacPaint 8x8 checkerboard data (576x720 monochrome)...");
            console.debug("--- generateCheckerboardMacPaintData START ---");
            const width = 576; // pixels
            const height = 720; // pixels
            const bytesPerRow = width / 8; // 72 bytes

            const headerSize = 512;
            const bitmapSize = bytesPerRow * height; 
            const totalPNTGDataSize = headerSize + bitmapSize;

            const pntgData = new Uint8Array(totalPNTGDataSize);

            // Fill header with zeros
            for (let i = 0; i < headerSize; i++) {
                pntgData[i] = 0;
            }

            const checkerSize = 8; 
            console.debug(`Checker Size: ${checkerSize}`);

            for (let y = 0; y < height; y++) {
                const yBlock = Math.floor(y / checkerSize);
                for (let xByte = 0; xByte < bytesPerRow; xByte++) {
                    let byteValue = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        const currentPixelX = xByte * 8 + bit;
                        const xBlock = Math.floor(currentPixelX / checkerSize);
                        
                        let isBlack = false;
                        if ((xBlock + yBlock) % 2 === 0) {
                            isBlack = true; 
                        }

                        if (y < 2 && xByte < 2 && bit === 0) { // Reduce debug noise, log only for first bit of relevant bytes
                             console.debug(`y:${y}, xPx:${currentPixelX}, yBlk:${yBlock}, xBlk:${xBlock}, (xBlk+yBlk)%2: ${(xBlock+yBlock)%2}, isBlack: ${isBlack}`);
                        }

                        if (isBlack) {
                            byteValue |= (1 << (7 - bit)); 
                        }
                    }
                    pntgData[headerSize + (y * bytesPerRow) + xByte] = byteValue;
                    if (y < 2 && xByte < 4) { 
                        console.debug(`y:${y}, xByte:${xByte}, byteValue: 0x${byteValue.toString(16).padStart(2,'0')}`);
                    }
                }
            }
            log(`Generated ${totalPNTGDataSize} bytes for PNTG data (Header: ${headerSize}, Bitmap: ${bitmapSize}).`);
            console.debug("--- generateCheckerboardMacPaintData END ---");
            return pntgData.buffer;
        }

        function buildBlockToFileMap(mfsVolume) {
            const blockMap = {};
            if (!mfsVolume || !mfsVolume.fileDirectory || !mfsVolume.abm) return blockMap;

            for (const file of mfsVolume.fileDirectory) {
                if (file.dataForkStartBlock > 0) {
                    let currentBlock = file.dataForkStartBlock;
                    while (currentBlock >= 2 && currentBlock < (mfsVolume.volumeInfo.numAllocBlocks + 2)) {
                        blockMap[currentBlock] = { file, fork: 'data' };
                        const nextIndicator = mfsVolume._getABMEntry(currentBlock);
                        if (nextIndicator === 0x001 || nextIndicator === 0x000) break;
                        currentBlock = nextIndicator;
                    }
                }
                if (file.resourceForkStartBlock > 0) {
                    let currentBlock = file.resourceForkStartBlock;
                    while (currentBlock >= 2 && currentBlock < (mfsVolume.volumeInfo.numAllocBlocks + 2)) {
                        blockMap[currentBlock] = { file, fork: 'resource' };
                        const nextIndicator = mfsVolume._getABMEntry(currentBlock);
                        if (nextIndicator === 0x001 || nextIndicator === 0x000) break;
                        currentBlock = nextIndicator;
                    }
                }
            }
            return blockMap;
        }
        
        function renderDiskVisualization(mfsVolume) {
            log("Rendering disk visualization...");
            visualizationContainer.innerHTML = ''; 
            if (!mfsVolume || !mfsVolume.volumeInfo) {
                log("MFS Volume data not available for visualization.");
                return;
            }

            const volInfo = mfsVolume.volumeInfo;
            const blockToFileMap = buildBlockToFileMap(mfsVolume);

            for (let i = 0; i < 2; i++) {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'disk-block block-boot';
                blockDiv.dataset.tooltip = `Boot Block\nSector: ${i}`;
                visualizationContainer.appendChild(blockDiv);
            }
            for (let i = 0; i < 2; i++) {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'disk-block block-mdb';
                blockDiv.dataset.tooltip = `Master Directory Block (MDB)\nSector: ${2 + i}`;
                visualizationContainer.appendChild(blockDiv);
            }
            for (let i = 0; i < volInfo.dirLengthBlocks; i++) {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'disk-block block-dir-reserved';
                blockDiv.dataset.tooltip = `Reserved File Directory Area\nSector: ${volInfo.dirStartBlock + i}`;
                visualizationContainer.appendChild(blockDiv);
            }

            for (let mfsBlockNum = 2; mfsBlockNum < volInfo.numAllocBlocks + 2; mfsBlockNum++) {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'disk-block';
                let tooltipText = `Allocation Block: ${mfsBlockNum}\nStatus: `;
                const abmEntry = mfsVolume._getABMEntry(mfsBlockNum);

                if (blockToFileMap[mfsBlockNum]) {
                    const { file, fork } = blockToFileMap[mfsBlockNum];
                    blockDiv.classList.add(fork === 'data' ? 'block-file-data' : 'block-file-rsrc');
                    tooltipText += `Used by File: ${file.filename} (${fork} fork)\n`;
                    tooltipText += `Type: ${file.type}, Creator: ${file.creator}\n`;
                    tooltipText += `File Logical Size (Data): ${file.dataForkLogicalLength}B\n`;
                    tooltipText += `File Logical Size (Rsrc): ${file.resourceForkLogicalLength}B`;
                } else if (abmEntry === 0x000) {
                    blockDiv.classList.add('block-free');
                    tooltipText += "Free";
                } else if (abmEntry === 0xFFF) {
                    blockDiv.classList.add('block-dir-alloc');
                    tooltipText += "Used by File Directory (overflow)";
                } else if (abmEntry === 0x001) {
                    blockDiv.classList.add('block-file-data'); 
                    tooltipText += "End of File marker (potentially part of a file)";
                } else if (abmEntry > 1 && abmEntry < 0xFFF) {
                    blockDiv.classList.add('block-file-data'); 
                    tooltipText += `Used (links to block ${abmEntry}, potentially part of a file)`;
                }
                else {
                    blockDiv.classList.add('block-unknown');
                    tooltipText += `Unknown/Special (ABM: 0x${abmEntry.toString(16)})`;
                }
                blockDiv.dataset.tooltip = tooltipText;
                visualizationContainer.appendChild(blockDiv);
            }
            
            document.querySelectorAll('.disk-block').forEach(block => {
                block.addEventListener('mousemove', (e) => {
                    tooltip.textContent = block.dataset.tooltip;
                    tooltip.style.display = 'block';
                    let x = e.pageX + 15;
                    let y = e.pageY + 15;
                    if (x + tooltip.offsetWidth > window.innerWidth) {
                        x = e.pageX - tooltip.offsetWidth - 15;
                    }
                    if (y + tooltip.offsetHeight > window.innerHeight) {
                        y = e.pageY - tooltip.offsetHeight - 15;
                    }
                    tooltip.style.left = x + 'px';
                    tooltip.style.top = y + 'px';
                });
                block.addEventListener('mouseout', () => {
                    tooltip.style.display = 'none';
                });
            });
            log("Disk visualization rendered.");
        }

        async function createAndSaveImage() {
            logOutput.textContent = ''; 
            visualizationContainer.innerHTML = ''; 
            tooltip.style.display = 'none';
            log("Starting MFS disk image creation...");
            try {
                const mfsVolume = new MFSVolume({ create: true, sizeKB: 400, volumeName: "CheckerDisk" });
                log("New 400KB MFS Volume 'CheckerDisk' created in memory.");
                log("Volume Info: " + JSON.stringify(mfsVolume.volumeInfo, (key, value) => 
                    value instanceof Date ? value.toISOString() : value, 2));

                renderDiskVisualization(mfsVolume); 

                const macPaintDataBuffer = generateCheckerboardMacPaintData();
                
                const metadata = { 
                    type: "PNTG", 
                    creator: "MPNT",
                    folderNum: 0, 
                    finderFlags: 0 
                };
                const filename = "Checker.ptng";

                log(`Writing "${filename}" to MFS volume...`);
                mfsVolume.writeFile(filename, macPaintDataBuffer, null, metadata);
                log(`File "${filename}" written successfully.`);

                log("Files on disk:");
                mfsVolume.listFiles().forEach(file => {
                    log(`- ${file.filename} (Type: ${file.type}, Creator: ${file.creator}, Data: ${file.dataForkSize}b, Rsrc: ${file.resourceForkSize}b)`);
                });
                
                renderDiskVisualization(mfsVolume); 

                const diskImageBuffer = mfsVolume.getDiskImage();
                log(`Total disk image size: ${diskImageBuffer.byteLength} bytes.`);

                const downloadLinkContainer = document.getElementById('downloadLinkContainer');
                downloadLinkContainer.innerHTML = ''; 
                const blob = new Blob([diskImageBuffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "CheckerDisk.dsk";
                a.textContent = "Download CheckerDisk.dsk";
                downloadLinkContainer.appendChild(a);
                log("Download link created for 'CheckerDisk.dsk'.");

            } catch (error) {
                log("Error: " + error.message + (error.stack ? `\n${error.stack}`: ''));
                console.error(error); // Also log full error to console
            }
        }

        document.getElementById('createImageBtn').addEventListener('click', createAndSaveImage);
    </script>
</body>
</html>